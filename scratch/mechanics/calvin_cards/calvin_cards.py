"""
CalvinCards is a best-of-three contested skill check masquerading as a collectable card game.

Round descriptions are generated according to 'Calvin-ball Rules' based on the contents of each players decks and their strategy choices.

Basic strategies are rock-paper-scissors.  For unskilled players with empty, unaffiliated decks, the game would reduce to skill checks with a +/-3 bonus depending on the outcome of the rps match up.

However, more rules come into play for players with special cards in their collection and skilled players.

An unskilled player with an unaffiliated deck will generate 3 weak-strategy options at each round: one each for rock, paper, scissors with a -1 power modifier.  This is modeled as spawning 3 temporary weak uncommon cards that will drive the action for that round.

The round description will include the cards that proxy each players' strategy and an unlimited number of "common" cards as required for the win/lose state.

Players may collect cards and add them explicitly to their deck, which is otherwise presumed to have infinite common cards and a few uncommons for strategy selections.  Explicitly collected uncommon/strategy cards provide a normally powered strategy choice, for example, a rock0.  Rare cards provide either a +1 bonus, or, for skilled players, rares can synergize with another uncommon/rare card to create a +2 strategy.

Skilled players may use "affiliated" decks.  Any strategy generated by an affiliated card will carry a +1 modifier and any automatically generated uncommons will be appropriately affiliated.  So, automatically generated weak uncommons will be normally powered, like rock-1 -> rock0, matching collected uncommons will be highly powered like rock0 -> rock1, and so on.  However, any strategy generated by a non-affiliated card will carry a -1 penalty!  Moreover, affiliations _may_ have innate bonuses and maluses when using specific strategies; these bonuses should always sum to 0.  So a 'red' affiliation may have bonuses +1 to paper, -1 to rock, blue may have +2 to rock, -1 to paper, -1 to scissors.  So an automatically generated red-deck rock strategy option would be rock-1 base, +1 for being a red card in a red deck, -1 due to red's malus with rock, so a total of rock-1 again.  However, a collected _red_ uncommon card paper strategy would be rock0 base, +1 for being a red card in a red deck, +1 for red's bonus with paper, so a total of rock2.  The same strategy from a non-red card would be -1 instead of +1, so back to rock 0.

Highly skilled players may can select 2 affiliations for their decks, giving them the sum bonuses and maluses from both for any card matching either affiliation, and generate synergy strategies from rare cards, which can be very powerful.

At the end of the day, each player selects a strategy with some power offset, say rock3 against paper0.  Then the rock-paper-scissors match-up is resolved, granting a +3 bonus to the winner, so rock3 -> power3, paper0 -> power3 as well.  The two levels are subtracted to give the relative difficulty, 0, or 50/50.  The difference between the player skill-level is added (2 vs 3 -> +1 for p2).  So p1 must make a difficult roll to win the round.

The opening round is then described using fanciful language around the key cards and strategies for each player given the round's outcome.  Appropriate common cards are referenced as part of the various "phases" of the round, even though they are not explicitly included in a player's "deck" of collected cards (only collected uncommons and rares).

Any cards used to generate strategies in the previous round are discarded (can only be used once per game) and new strategies are generated.  For round 2.  If p1 lost round 1, round 2 is described as a defensive struggle to stay in the game, if p1 won round 1, it is described as an aggressive press with advantage.  If a third round is required, it is described as the "end game".
"""


from __future__ import annotations
from typing import Self
from enum import Enum

from tangl.core.entity import Singleton
from tangl.story.concept.actor import Actor

class CCGPlayer(Actor):
    cc_skill: int
    cc_collection: set[CalvinCard]

class CCRarity(Enum):
    COMMON = "common"
    # flavor only, generated randomly during play according to deck and strategy
    UNCOMMON = "uncommon"
    # yield a strategy selection, minimal number spawn randomly according to deck and strategy, or may be included explicitly from player's collection
    RARE = "rare"
    # yield a strong strategy or synergy, require a skilled player, must be included explicitly from player collection
    LEGENDARY = "legendary"
    # yield a strong strategy or synergy without skill requirement, unique quest rewards, must be included explicitly

    # an unc will create 1-3 _strategies_ that sum to 0, so r+1, p-1 or s0, for example
    # a rare will create 1-3 _strategies_ that sum to +1, so r+1, p-1, s+1, or s+1, for example

class CCStrategy(Enum):
    ROCK = "rock"
    PAPER = "paper"
    SCISSORS = "scissors"

class CCWords:
    adjs: list[str]
    nominals: list[str]
    prefixes: list[str]

    sp_adjs: list[str]
    sp_nominal: list[str]
    sp_prefixes: list[str]

class CCAffiliation(Singleton, CCWords):
    name: str
    modifiers: dict[CCStrategy, int]

    # cards have a single affiliation, decks may have none, one (skilled, affiliated uncs), or two (very skilled, affiliated rares)

    # affiliations give bonuses/maluses for/against different strategies that sum to 0

    # unaffiliated decks spawn poor strategies at each round with a -1 malus (if none are present)
    # an affiliated deck will spawn simple strategies at each round according to its modifiers (if none are present)
    # dual affiliated decks spawn strategies as the _average_ modifier power for each strategy (if none are present)

class CCVariant(Singleton):
    # common (caste sapphire), or a regional-reskinning for names, etc.

    name: str
    rounds: list[str]  = ["opening", "press", "defend", "closing"]
    # - Always start with an "opening" round
    # - If open is won, round 2 is "press", otherwise it's "defend"
    # - If a third round is required, play a "closing" round
    phases: list[str]
    # round phases
    strategies: dict[CCStrategy, CCWords]
    affiliations: dict[str, CCWords]
    # affiliations may be called anything, variants need not have the same number of affiliations, but any affiliation
    generics: CCWords


StrategyType = int  # rps+


class CalvinCard:
    seed: int = ...   # fill in anything that is Unset, serialize as seed + set items

    name: str
    rarity: CCRarity
    affiliation: CCAffiliation
    modifiers: dict[Strategy, int]
    # common cards have no modifiers (they don't represent strategies)
    # uncs have modifiers that sum to 0 (i.e., 1/0/0 or 1/-1/1)
    # rares/legendaries have modifiers that sum to 1 (i.e., 3/-1/-1)

class CalvinDeck:
    affiliation: CCAffiliation
    cards: list[CalvinCard]

    @classmethod
    def set_affiliation(cls, affiliation: CCAffiliation, cards: list[CalvinCard]) -> Self:
        # filter cards to include affiliates
        return cls(affiliation=affiliation, cards=cards)

    def get_opening_strategies(self, skill: int) -> list[Strategy]:
        ...

    def get_closer_strategies(self, skill: int) -> list[Strategy]:
        ...

# Wrapped singleton
class Strategy:
    strategy_type: StrategyType
    power_level: int
    modifiers: dict[Strategy, int]
    skill_requirement: int
    required_cards: list[CalvinCard]  # something like any blue, blue +1, blue+green,

from tangl.mechanics.game import Game, ChallengeBlock

class CCGGame(Game):
    players: list[CCGPlayer]
    narrative: str

    def initialize(self):
        # Set up game state
        ...

    def opening_move(self):
        # Handle opening strategies
        ...

    def main_phase(self):
        # Generate narrative and update game state
        ...

    def closing_move(self):
        # Handle closing strategies
        ...

    def resolve(self):
        # Determine winner and generate final narrative
        ...

class CCChallenge(ChallengeBlock):
    ...