from __future__ import annotations
from typing import Literal, Optional, TYPE_CHECKING
from base64 import b64encode
from uuid import UUID

from pydantic import Field, field_serializer, AnyUrl

from tangl.type_hints import Pathlike
from tangl.core import ContentFragment, HandlerPipeline, PipelineStrategy, ResourceInventoryTag as RIT
# from tangl.media.enums import MediaRole
from tangl.media.type_hints import Media
from .media_presentation_hints import MediaPresentationHints


MediaFragmentType = Literal['media', 'image', 'vo', 'music', 'sfx', 'anim', 'mov']
DataContentFormatType = Literal['url', 'data', 'xml', 'json']

on_handle_media_fragment = HandlerPipeline[RIT, Media](label="on_handle_media_fragment", pipeline_strategy=PipelineStrategy.PIPELINE)
# Media fragments can have a RIT as content and need to be _dereferenced_ at the service
# layer to an actual data object or file url

class MediaFragment(ContentFragment, extra='allow'):
    """
    This is the final data type that is produced by the service layer from a media resource generated by the domain layer.

    Attributes:
      - uid (UUID): Unique identifier of the generating story entity.
      - fragment_type: media, image, vo, music, sfx, anim, mov
      - media_role (MediaRole): Intended use, e.g., `narrative_im`
      - content: Path, xml or base64 encoded data, or RIT
      - format: path, str, bytes, rit
      - text (str): Rendered content text (caption, label, lyric, etc.)

    Only one of url or data may be provided.
    """
    fragment_type: MediaFragmentType = Field("media", alias='type')
    content: Pathlike | bytes | str
    content_format: DataContentFormatType = Field(..., alias='format')
    media_hints: Optional[MediaPresentationHints] = None

    # media_role: MediaRole

    # These may be passed in directly from a ref with external or embedded data
    url: Optional[AnyUrl] = None  # either url or data
    data: Optional[str] = None    # svg or base64 encoded

    @field_serializer("content")
    def _encode_data_content(self, content):
        if self.content_format == "data":
            return b64encode(content)
        return str(content)

    #: Processed by service layer and discarded
    media_record_id: Optional[UUID] = Field(None, exclude=True)

    # @classmethod
    # def from_media_record(cls, media_record: 'MediaRecord', **kwargs) -> 'MediaFragment':
    #     ...

    # @model_validator(mode='after')
    # def _check_exactly_one(self) -> Self:
    #     if not any([self.url, self.data, self._record]) or all([self.url, self.data, self._record]):
    #         raise ValueError("Exactly one of `url`, `data`, or `record` must be provided")
    #     return self


