
from __future__ import annotations
from typing import *
import inspect

import attr

from .manager import EntityManager

if TYPE_CHECKING:  # pragma: no cover
    from .entity import Entity

@attr.define
class EntityMeta:
    """Structured metadata for a related collection of entities"""

    #: List of entities sharing this meta data
    entities: Dict = attr.ib( factory=dict )
    #: Global data cache that can be referenced by any member
    data: Dict = attr.ib( factory=dict )
    #: Ref if the entity collection was generated by a manager
    manager: EntityManager = None
    #: Ref to the context manager if exists
    parent: Any = None

    _override_classes: Dict[str, type[Entity]] = attr.ib( factory=dict )
    def override_cls(self, base_cls: type[Entity] | str) -> type[Entity]:
        if inspect.isclass( base_cls ):
            key = base_cls.__name__
        elif isinstance( base_cls, str ):
            key = base_cls
        else:  # pragma: no cover
            raise TypeError(f"No key for {base_cls} to coerce")

        if key in self._override_classes:
            return self._override_classes[ key ]

        elif self.manager:
            return self.manager.override_cls(  base_cls )

        elif inspect.isclass( base_cls ):
            return base_cls

        raise TypeError(f"No override or default cls for {base_cls}")  # pragma: no cover

    _template_maps: Dict = attr.ib( factory=dict )
    def template_maps(self, base_cls: type[Entity]) -> dict | None:
        res = {}
        if self.manager:
            res |= self.manager.template_maps( base_cls )
        if self._template_maps:
            mro = [cls.__name__ for cls in base_cls.__mro__]
            for k, v in self._template_maps.items():
                if k in mro:
                    res |= v
        return res

    def ns(self, **kwargs) -> dict:
        _ns = {'meta': self.data}
        _ns |= self.inv_entities
        if self.manager:
            _ns |= self.manager.ns(ctx=self, **kwargs)
        return _ns

    # Collection accessors

    def add(self, obj: Entity):
        self.entities[obj.eid] = obj

    @property
    def inv_entities(self):
        return {v.path: v for k, v in self.entities.items() }

    def __getitem__(self, key: str) -> type:
        if key in self.entities:
            return self.entities[key]
        elif key in self.inv_entities:
            return self.inv_entities.get(key)
        raise KeyError

    def __contains__(self, key) -> bool:
        if key in self.entities:
            return True
        elif key in self.inv_entities:
            return True
        return False

    def filter_values(self, entity_cls: Type[Entity] = None, filt: Callable = None):

        def _filt(obj: Entity):
            if entity_cls and not isinstance(obj, entity_cls):
                return False
            if filt and not filt(obj):
                return False
            return True

        res = list( filter(_filt, self.entities.values()) )
        return res

    #: bookmarked node
    mark: Entity = None
    #: story clock reference for traversable entities
    now: int = 0
