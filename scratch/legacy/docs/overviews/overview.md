StoryTangl Key Concepts
=======================

- An interactive fiction engine
- Flexible, easy to author content for, and extensible
- Provides many built-in features and hooks for custom mechanics
- Well documented for users, content authors, and developers
- Simple to set up and use

Technical Stack
---------------
- Language: python ^3.11
- Key Dependencies: pydantic, pillow, markdown, jinja
- Development Tools: poetry, pytest, git, sphinx, drone
- Distribution: pip, docker, pyinstaller

Core
----
Basic data structures and functions for all managed entities

**Managed Entities**
- Have a unique id
- Have string "tags"
- Serializable as kv (using _pydantic_)

**Handlers**
- Class functions implementing entity behaviors
- Implements a flexible, hookable method resolution strategy that considers class-subtypes, explicit ordering, and output format

**Entity Handlers**
- Create new entity (change class, kwargs)
- Represent entity state as context (namespace)
- Runtime eval/check conditions and apply/exec effects given context
- Enable/disable entity based on conditions (available)
- Realize content given context (render)

**Singleton Entities**
- Immutable
- Serializable by name
- Instance inheritance mixin

**Graph Entities**
- Mutable, has state
- Collection of node entities
- Serializable as collection of nodes

**Node Entities**
- Mutable, has state
- Has children/parent references
- Always part of a graph

**Wrapped-Singleton Nodes**
- Generic for wrapped type class
- Wraps a singleton with instance-specific mutable state

**Indirect Connecting Nodes (Edges)**
- Generic for successor class
- Parent is predecessor
- References a successor
- Successor may be referenced, filtered, or created

**Traversable Graphs and Nodes**
- Traversable graph has a cursor reference to the 'current' node
- Cursor can be directed to follow traversable connecting nodes to a different node
- Cursor directives may be user selected or automatically triggered

**Graph and Node Handlers**
- Validate conditions and associate parent/child nodes (node-handler)
- Validate conditions and traverse edges, triggering effects, content realization, and additional cursor directives, can determine initial cursor position (graph-handler)

Story
-----
Related to organizing narrative concepts into managed entities.

**Story (Traversable Graph) and Story Nodes**
- Story holds an ordered journal of content realized during traversal
- Story nodes types are divided into 4 categories: scenes, actors, places, and assets
- Story api: `get journal entry`, `get story info`, `do story action`, `get story media`
- Story dev api: `goto node`, `inspect node`, `check expr`, `apply expr`

**Scene**
- A scene node is the root of a tree of connected block nodes embedded in the story graph
- A block represents a small logical chunk of content, usually separated by choices
- Block nodes are linked to other blocks by actions, redirections (prior to content generation), and continues (post content generation)
- Blocks may contain smaller 'micro-block' content fragments, like dialog, choices, or media
- Connections may be dynamically generated by filter (menu blocks)
- Scenes may have indirect connections to actors (via roles) and places (via locations), attaching specific actor or place instances to a scene via reference, filter, or creation is called "casting roles" or "scouting locations"

**Actor**
- An actor is a story node that can be attached to multiple scene roles or locations (indirect connections)
- Actors can delegate to several types of specialized child components for different features such as a demographic profile, look, or outfit

**Place**
- A place represents a fixed setting for multiple possible scenes
- Places/locations are implemented using the same interface as actors/roles

**Asset**
- An asset-singleton represents an immutable noun in the story world, for example, a sword or some gold
- Asset-singletons are considered "fungible", they are counted and stored in a wallet that can be managed by a specialized fungible trade handler
- Stateful assets (wrapped singleton nodes) such as asset-roles (a retainer) or asset-locations (an ownable castle) are managed by the association/trade handler
- Badges are asset-singletons that are assigned and unassigned dynamically based on conditions

**World**
- A world is a singleton story node that serves as a factory for new stories
- The world holds a story's script, template manager, media resource manager, asset manager, and a world-specific handler strategy registry
- All stories keep a reference to their world
- World public api: `get world info`, `get world list`, `get world media`
- World client api: `create story`
- World dev api: `get scene list`

Content
-------
Related to ingesting story scripts or generating story output

**Script Manager**
- Pydantic models for all story node types and integrated story script
- Script manager holds a script and metadata for a given world, can feed entity template data to a world for creating a new story
- Script manager can be modified to accept alternative script models or types (markdown, for example)

**Story Journal**
- Ordered list of content fragments generated during story traversal
- Entries indexed at each user interaction

Renderable story nodes implement 2 main content generation functions: 
- `describe` to create a narrative text passage for the node
- `media_spec` to create a media specification for the node

**Narrative Handlers**
- Narrative creators (updating/creating text to match scene state and character traits using generative AI and/or NLP/regex)
- Dialog specs and journal fragments (attach actor, attitude to each statement)
- Language tools

**Media Handlers**
- Media connector nodes (connects story node to media resource)
- Media resource manager
- Media creators (updating/creating media to match scene state and character traits using generative AI and/or svg assemblies)
- Staging specs and journal fragments (attach media transition, position to audio cues)

Mechanics
---------
Extensions for specific types of interesting narrative constructs, such as games or sandbox behaviors that can be composed with basic story entities.

**Actor extensions**
- Demographic profile (personal names, origin, age, body swapping)
- Look (describe actor physical traits, create avatar media)
- Outfit (describe wearable assets, remove/wear actions)
- Ornaments (describe piercings, tattoos, etc.)

**Games**
- Game entities and move handler
- Interactive game blocks

**Sandboxes**
- Location maps
- Scheduled and localized events
- Mobile actors (mobs)

**Stats**
- Stat domains and ranks
- Stat challenges (cost, difficulty, reward)
- Situational effects (update tags, bonus/malus)
- Activity (stat test) blocks

Service
-------
Interface between the story and the game client, intended to support multiple active users each with multiple active story worlds

**Configuration handler**
- Uses DynaBox

**Persistence**
- Presents as a mapping
- Supports various text/binary serializers (json/yaml, pickle)
- Supports various backends (in-memory, files, _redis_, _mongo_)

**Users**
- User api: `create user`, `get user info`, `update user`

**System**
- system api: `get system info`
- system dev api: `reset system`

**Service Manager**
- Wraps story and user api with persistence manager
- Provides world and system api
- Response handler remaps media resources to server locations and converts markdown to html in response objects

REST Server
-----------

- Uses _fastapi_
- Creates a local service manager
- Routers map http calls to service api
- Provide secondary apps for serving static media and web client files

Clients
-------
Clients are generally 'dumb', they rely on the story api to get journal entries for display and to submit user interactions.

**Cli**
- Uses _cmd2_ interpreter
- Controllers map statements to service api
- May create a local service manager
- or - may connect to a remote rest server using _requests_

**Tcl**
- Simple graphical interface

**Web**
- Uses _vue3_, _vuetify_
- Connects to a remote rest server using _axios_

Clients can also be adapted from other 'smart' platforms, like Ren'Py or RPG maker, via adapters.

Docs
====

- Uses _sphinx_
- Separate user (author) and developer/api guides
- Extensive docstrings for autodoc

