Abstract Narrative Graph Principles
-------------------------------

The graph begins in a state of possibility, with nodes potentially active but unvisited. As interaction occurs, parts of the graph become realized (visited) while others may fade (deactivate), creating a unique emergent narrative for each traversal.

Emergent Structure: Story structure emerges from interaction rather than being fully predetermined.
Flexibility: Accommodate both authored content and procedurally generated elements seamlessly.
Extensibility: New node types, edge types, or state schemas can be added without disrupting existing structures.

A graph of typed nodes and typed edges.

Like a scene node may have many children blocks.  When we get to a scene, we have to find the entry block and visit it, that gives us a narrative fragment and a set of possible paths for advancing the story, either by visiting scene neighbors, or by visiting one of it's own children, or by visiting another scene's entry point, or an arbitrary block in another scene, or a rule for creating a new block to visit, etc.  Then, as you say, the context passes up through the parent structure to get a scoped variable namespace.  Actors, places, objects are usually attached at the scene/container level and available at fixed names to all nodes within that scene.  Usually a traversable node will either be a group or a single block (possibly with related concepts).  Although nothing precludes a container node from generating content fragments when it is visited before deferring to a child block.

I think of the graph as a forest of scene dags/trees with nested dags/scene trees, and concept clusters, like an actor, their outfit, their relationships, etc. which can be linked into the scenes at various levels.

Node types represent semantic concepts: narratively traversable act/scene, actors, places, and objects/props/assets.

Scenes may contain sub-elements called blocks.  Each block typically generates one or more story fragments when it is traversed by the narrative cursor.  Actors and places are nodes that are created from templates and can be dynamically linked in to many scenes through 'roles' and 'locations'.  Assets are similar, but based on wrapped or counted singletons.

Scenes can contain blocks and local concept references
Blocks generate content and provide actions
Concepts can be referenced globally or locally within scenes
Variables cascade through the hierarchy (child → parent → scene → global)
Actions can target any node through various reference schemes

There are three types of edges in the graph: components (children, like an actor's outfit or a scene's blocks), indirect (role or location children linked to actors/places or other associations), and traversable (represent a navigable cursor path).

Nodes can carry local variables, as well as constraints on when they are available for traversal or other access and effects that they invoke when traversed or accessed.  Node conditions and effects are evaluated in a scoped context.

Basic management functions include:
- gather the scoped namespace up to the global variables in the story and user objects
- check the conditions at a node
- apply the effects at a node
- render the content or content descriptions generated by traversing the node
- move the cursor and try to enter a new node

Entering a node consists of:
- check for redirects
- gather context
- check available
- apply effects
- render the narrative content
- check for continuations

I have two "layers" in the graph, one for traversable nodes, story beats that are logically linked to one another and generate groups of content fragments, and concept nodes, which are things that can be tied to a particular traversable node or multiple nodes, like a character, a setting, an item.  They are logically the same except that traversable nodes can be visited and the graph keeps a cursor indicating the currently visited node when the logic blocks for user input.

Represent complex, multi-dimensional relationships: A single event could simultaneously affect multiple characters, locations, and plot elements.  ("hyper-edges", you can represent relationships like "Character C uses Item I at Location L to affect Character D" as a single hyperedge.)

The traversable nodes form the primary "path" through the narrative, while concept nodes create a secondary dimension of connections that cross-cut the main path.

Thematic Linking: Narrative elements that share themes or motifs can be connected across different parts of the story.

State is tracked directly on the graph, so each node can have a flexible, scoped local context rather than trying to use a fixed dictionary of global variables that are mostly irrelevant everywhere else and can become out of date or have namespace conflicts.  Moreover, state updates are not just variables, the graph itself can have new members added (or possibly removed, although it's probably better to just mark them inactive so they are still available for reference if we want to know how many times a character visited a park, for example, before the park was "removed: from the game world by some mechanism.). So the nodes are mutable, and the graph itself can add or remove nodes according to rules.

- Variables are naturally scoped to where they matter, can cascade namespaces from parents and related nodes
- Less risk of namespace pollution
- More intuitive organization (e.g., character stats live on character nodes)
- Dynamic Graph Modification allows concepts to be introduced and linked into the story on-demand
- Graph as Living History The graph itself serves as both current state and historical record of the narrative journey.


Core
----
Basic data structures and functions for all managed entities

**Managed Entities**
- Have a unique id
- Have string "tags"
- Serializable as kv (using _pydantic_)

**Handlers**
- Class functions implementing entity behaviors
- Implements a flexible, hookable method resolution strategy that considers class-subtypes, explicit ordering, and output format

**Entity Handlers**
- Create new entity (change class, kwargs)
- Represent entity state as context (namespace)
- Runtime eval/check conditions and apply/exec effects given context
- Enable/disable entity based on conditions (available)
- Realize content given context (render)

**Singleton Entities**
- Immutable
- Serializable by name

**Graph Entities**
- Mutable, has state
- Collection of node entities
- Serializable as collection of nodes

**Node Entities**
- Mutable, has state
- Has children/parent references
- Always part of a graph

**Wrapped-Singleton Nodes**
- Wraps a singleton with instance-specific mutable state

**Indirect Connecting Nodes (Edges)**
- Generic in successor class
- Parent is predecessor
- References a successor
- Successor may be referenced, filtered, or created

**Traversable Graphs and Nodes**
- Traversable graph has a cursor reference to the 'current' node
- Cursor can be directed to follow traversable connecting nodes to a different node
- Cursor directives may be user selected or automatically triggered

**Graph and Node Handlers**
- Validate conditions and associate parent/child nodes (node-handler)
- Validate conditions and traverse edges, triggering effects, content realization, and additional cursor directives, can determine initial cursor position (graph-handler)

Story
-----
Related to organizing narrative concepts into managed entities.

**Story (Traversable Graph) and Story Nodes**
- Story holds an ordered journal of content realized during traversal
- Story nodes types are divided into 4 categories: scenes, actors, places, and assets
- Story api: `get journal entry`, `get story info`, `do story action`, `get story media`
- Story dev api: `goto node`, `inspect node`, `check expr`, `apply expr`

**Scene**
- A scene node is the root of a tree of connected block nodes embedded in the story graph
- A block represents a small logical chunk of content, usually separated by choices
- Block nodes are linked to other blocks by actions, redirections (prior to content generation), and continues (post content generation)
- Blocks may contain smaller 'micro-block' content fragments, like dialog, choices, or media
- Connections may be dynamically generated by filter (menu blocks)
- Scenes may have indirect connections to actors (via roles) and places (via locations), attaching specific actor or place instances to a scene via reference, filter, or creation is called "casting roles" or "scouting locations"

**Actor**
- An actor is a story node that can be attached to multiple scene roles or locations (indirect connections)
- Actors can delegate to several types of specialized child components for different features such as a demographic profile, look, or outfit

**Place**
- A place represents a fixed setting for multiple possible scenes
- Places/locations are implemented using the same interface as actors/roles

**Asset**
- An asset-singleton represents an immutable noun in the story world, for example, a sword or some gold
- Asset-singletons are considered "fungible", they are counted and stored in a wallet that can be managed by a specialized fungible trade handler
- Stateful assets (wrapped singleton nodes), asset-roles (a retainer), and asset-locations (an ownable castle) are managed by the association/trade handler
- Badges are asset-singletons that are assigned and unassigned dynamically based on conditions

**World**
- A world is a singleton story node that serves as a factory for new stories
- The world holds a story's script, template manager, media resource manager, asset manager, and a world-specific handler strategy registry
- All stories keep a reference to their world
- World public api: `get world info`, `get world list`, `get world media`
- World client api: `create story`
- World dev api: `get scene list`
