StoryTangl
==========

The abstract narrative graph library for interactive stories

General Story Space
-------------------

A story-space is a bounded, high-dimensional domain for all stories of a particular 'form'.

A discrete narrative is generated by navigating through the events and concepts embedded in that space.  This traversal incrementally collapses story space and generates a projection of the story.

We need three different models for members of a story space at different phases of its lifecycle.  

- First, a model for an abstract story-space.  This could range from a trivial example of a pre-navigated novel or short story, to a discrete story model like a cyoa, with discrete possible paths and consequences pre-determined, to a continuous story model, like an rpg with a set of rules and maps that can generate an infinite number of stories, or various combinations thereof.  A single model need not cover all possible representations, more important is what the api is, in particular, how we can sample from a space to navigate within a story.  

In **StoryTangl**, this model is a database of templates for story concepts and plot points, annotated with links between them, and a set of handlers for domain-specific graph updates and projections.

- Second is a data model for tracking the state of a story path being navigated/already navigated through the space.  What story space it belongs to, what navigation choices have been made, how the story world has been effected, what roles/places/events/scenes/choices have been created/sampled/seen/discarded/modified.  This model is dyanmically mutable, so it should be easily serializable or otherwise amenable to stateless updates.  

In **StoryTangl**, this is an abstract graph derived from concept and plot elements sampled from the story space, then represented as data models and rules that can be manipulated by an interpreter.  

- Third, we need a model for the the presenter to use in communicating the projected story with a client.  This can be a json schema, but it should also include a negotiation where the client can declare its features/restrictions, and probably a (separate?) communication protocol for the presenter to request media or narrative creation for a story-state update, either from the interpreter holding the story model, or from federated services like an LLM or gen ai image service or resolved link from a media server.

In **StoryTangl**, this a projection layer of graph called the "journal", which has special rules for mediating between the story projection and a simple client api.  Mediating nodes are called "journal fragments".  A projected story is a list of journal fragments, possibly with groupings and bookmarks.

The Abstract Narrative Graph Representation
-------------------------------------------

StoryTangl's Abstract Narrative Graph structure provides a concrete definition for a high dimensional story-shape space and various tools for different interactions with it.  

There are 3 'layers' of nodes in an abstract narrative graph: concept nodes, structure nodes, and projection nodes.

**Structure nodes** represent the kind of plot structure you might see in a classic cyoa book, "you are at a white house, if you want to go in, follow this edge".  Structure nodes are connected by plot-traversable edges into scene DAGs.  The plot layer of the story graph is a collection of scene trees.

Realizing a narrative from the graph is a guided graph traversal problem.  As structure nodes are visited, they invoke a graph update, open up new paths and close old ones, and then project their payload down onto the linear projection layer as a journal fragment.  Each plot node may generate many fragments, which are appended onto a bookmarked list (the journal) while keeping track of their originating plot node and linked concepts.  

**Concept nodes** are not visitable, but they can be dynamically linked to multiple nodes to fill various roles.  For example, an actor may fill similar roles in different scenes, or a piece of information may be discovered by different plot mechanisms, or a uniform 'look' might be shared by actors in multiple roles.

**Projection nodes** are orgnanized strictly linearly into a 'journal'.  Each journal fragment knows which node created it, so the journal can be queried both for which nodes have been visited/actions taken, and also for which concepts have been introduced.  For example, if the journal doesn't already know about a particular actor through a realized plot node, we might provide a summary description when she is introduced.  Or if a minor event was missed in the plot, we can provide a canonical description ("a narrative waiver").

Concepts that the plot has recruited but are unknown to the reader are considered "narrative debt", like a scene that starts _in media res_ incurs the narrative debt of introducing the scene later.  A mystery is obliged to carry the narrative debt of "who done it" until the end.  Dramatic irony is a "narrative credit", a concept is presented before the event that will recruit it.  

The concept layer annotates potential narrative debts or credits as landmarks or symbols on certain nodes, and the goal of the plot traversal is ultimately to balance the narrative landmarks enumerated in the concept layer with the narrative landmarks presented in the journal.

- The concept layer is mutable during traversal, existing concepts can be updated and new concepts can be introduced (need a new actor to fill a role).
- The plot layer is locally mutable, that is, individual nodes can be updated, but new plot elements are generally not going to be dynamically introduced.
- The content layer is append-only and journal fragments are frozen.

Graph Manager
-------------

StoryTangl's graph manager has a few key jobs, each of which can be intercepted and modified with plugin hooks:

- create/init a new graph and nodes from a templates ("create story", "create node")
- query conditions on a node in the context of linked/recruited/owner nodes ("get context", "check conditions")
- update a node's local attributes, including adding and removing links/children ("get context", "apply effects")
- move the graph's cursor to a new node, which implies validating availability and a graph and journal update ("check availability", "traverse edge", "visit node")
- invoke a node's render function and update the journal ("get context", "render content", "update journal")
- Get part or all of the journal formatted within client constraints ("get journal")
- Roll back the cursor and graph state using history diffs stored along with the journal ("undo")

New story graphs are generated from a "story world", which provides a set of node templates and graph manager plugins.  The world is compiled from scripts, media, and code snippits according to the rules and format of whatever compiler is being used.  I imagine a range of compilers, from a trivial compiler that just takes templates as unstructured data and structures them into plot nodes, to a functional compiler, that takes a set of concept nodes with annotated depenencies and infers a graph of possible plot paths from the start to the end.

As story graphs are collapsed into a journal, the journal fragments can be incrementally provided to a user client that may support different levels of styling and media and returns simple interactions/choices/inputs to the story server.  For example, a CLI, a web interface, a TCL client, or a Ren'Py plugin.

Client Interactions
-------------------

- One interaction role is **creator**, an agent that defines a potential story space.  
- One role is **navigator**, an agent that can collapse a potential story space into one or more realized story threads, either interactively or according to algorithmic rules.  
- The final role is **presenter**, an agent that can format a realized story thread according to the capabilities of the reader (actual media, language, markup, metadata for a client to consume).

Each role's interactions focus on a subset of the graph manager's features.

Key creatior interactions:

- create a new story from a world

Key navigator interactions:

- follow an edge with parameters
- undo prior step

Key presenter interactions:

- get the current journal update

Example
-------

Let's consider in the context of a simple example -- a linear story, a discrete example -- a cyoa adventure, a discrete+ example like an rpg sandbox with both pre-rolled and dynamically created places and events, and a continuous example -- although we can shelf that for now since I can't think of a trivial example.

A story world description goes in one end, a reader gets to make choices or otherwise interact with the system to collapse a unique story, and a linear sequence of narrative and media come out the other end in a format suitable for a generic client to consume.

For our proof of concept, I imagine a story world defined as a graph of interconnected narrative concepts -- in particular cardinal types for, scenes/content blocks, actors, places, and objects/things are all nodes.  Nodes can carry components, or links to other nodes in the form of edges.  Edges between content blocks are narratively traversable.  Edges between content blocks and actors or places are roles and settings respectively.  These may be pre-set or created/defined dynamically.  Things are usually carried by scenes, places, or actors in a sub-component called a wallet.

A story instance is a copy of the graph structure, with references back to the world templates.  The graph may evolve over time away from the template reference, and it will accumulate local information at various nodes as actors change outfits, for example, or scenes are navigated or pruned, or new nodes are dynamically added in according to the base world's rules.

The story instance is managed by the narrative daemon, which takes external input, updates the story instance state, and renders the state update into a candidate linear narrative thread.  Finally, a server/client layer transforms the thread into the final presentation by adding, transforming, and culling elements according to the client's capabilities and preferred formats.

The server and narrative daemon are stateless and can manage many story worlds (templates and rules) and story instances (states) in parallel.  There is also a meta-story layer for a user/reader that aggregates summary data from all story instances belonging to that user for reference within any of their story instances (achievements, unlocks, turns played, etc.).

For a python server implementation, clients could range from a cli or tcl interface that serves a single world and user and manages its own story daemon, to a web client that communicates with a REST server via json and http, to a renpy program with an adapter that sideloads its own story daemon or refers to a remote story daemon via the same REST interface as a web client would.

Design
------

This metaphor draws from various frameworks, like Kantian transcendental epistomology (concepts are noumenon, plot is structure, journal is phenonmenon), waveform collpase (concept and plot graphs describe possibile states, journal is a measured function), compiler theory (concepts are symbols, plot is a semantic tree, journal is linked output), and package management (concepts are providers, plot points have dependencies, content is locked).

Technical Design
----------------

We are using Python to develop a reference graph manager, compiler, and story server.  

We are using Poetry, Pydantic, pytest, Sphinx, and git for validation, package management, and source control.

StoryTangl separates concerns into four main layers—**data**, **business**, **service**, and **presentation**—to handle everything from persistent storage and user management to story logic and multi-format rendering. This modular design supports scenarios ranging from **classic CYOA** branching to **open-world RPG** structures with concurrency, dynamic node creation, skill checks, and more.

### 1. Data Layer

- **Responsibility**: Persisting all story state (graph nodes, edges, user data, version histories) in a robust, flexible manner.  
- **Goal**: Keep the **business layer stateless** by externalizing serialization and storage, so stories, user info, and logs/journals can be reloaded or shared among users or sessions.  
- **Entities to Serialize**:
  1. **ASG State** (the Abstract Story Graph, including dynamic nodes, references, and changes),  
  2. **User Data** (achievements, authorization, multi-story stats),  
  3. **Undo/Redo History** or version control diffs/snapshots,  
  4. **Story Journal** (the generated text, media references, or “timeline” of events as the user navigates the story).

Persistence is of primary importance, so the graph and current state should be organized easily serializable and agnostic to format (json, pickle files, redis, mongo, graph dbs, etc.).  History ties into this, so we need to store a history of prior states or diffs along with the journal layer to be able to 'roll back' event chains.  We also want to allow instance stories be part of a collection, such as for sharing achievements and stats across all stories belonging to a particular reader/user.

### 2. Business Layer

- **Responsibility**: Implements the **core logic** of story management, graph traversal, condition checks, effect application, and hooking.  
- **Sub-Layers (the “3 cores”)**:
  1. **Source Content & Scripting** – Takes user-friendly definitions (YAML, DSL, Python modules, etc.) and compiles them into the internal ASG templates.  
  2. **State Representation & Management** – Maintains the “live” Abstract Narrative Graph (ANG) instance. This includes dynamic node creation, concurrency logic, hooking, and condition/effect resolution.  
  3. **Narrative & Media Output** – Generates, assembles, and tracks the final text/media “fragments” (the **journal**). The story “collapses” from possible paths to a single user-experienced sequence.

In essence, the **business layer**:

- **Manages the ASG**: The typed nodes/edges, hooking system, scoping of variables, plus concurrency or branching.  
- **Handles** node entry, condition checks, effects, and building the user’s “journal.”  
- **Remains “media-agnostic”**: Leaves final rendering details (fonts, colors, image placement) to the **presentation layer**.

### 3. Service Layer

- **Responsibility**: Exposes **RESTful** or **federated** APIs that front-end clients can call.  
- **Typical API Endpoints**:
  - **Story Interaction**: retrieving the current journal, posting a choice or action, or getting partial state info like a map or summary.  
  - **Account Management**: user login, user achievements, creating/deleting stories, etc.  
  - **System Features**: listing available story worlds, loading new modules, distributing or federating content-generation tasks.

The **service layer** allows multiple front-end clients (CLI, web, or an engine plugin) to interact with the same story logic seamlessly.

### 4. Presentation Layer

- **Responsibility**: Displaying the story to the end-user in a device-appropriate format. Could be:
  - A **CLI** with minimal media handling,  
  - A **Web Interface** that supports images, color-coded text, or dynamic layouts,  
  - A **Ren’Py** or other game engine plugin, etc.

Because **tANGL** defers exact rendering logic to the **presentation layer**, it can “negotiate” capabilities (like whether to show an image or fallback to text) at runtime without changing the underlying story logic.

Implementing the ASG
--------------------

At the heart of **tANGL** is the **Abstract Story Graph**, a **typed, directed** structure representing all possible story states and transitions:

### Node Types

1. **Scenes (Acts)** – Traversable narrative points. Contains sub-elements (“blocks”), branching logic, conditions/effects, and user choices.  
2. **Actors (Characters)** – Reusable entities that can appear in multiple scenes, carrying stats, inventories, or relationships.  
3. **Places (Settings)** – Locations or environments. Scenes link to places as “locations,” which can be swapped or reused across different arcs.  
4. **Assets (Objects / Props)** – Items or resources, potentially countable (like gold) or unique (like “the cursed sword”).

### Edges and Relationships

1. **Components / Children** – Hierarchical sub-structures (e.g., scene blocks, outfit items).  
2. **Indirect Links** – “Role” or “location” references that connect actors or places to scenes.  
3. **Traversable Paths** – The edges that represent the user’s navigable route from scene to scene (with conditions, skill checks, or branching).

**Scoped Context**: When traversing a scene node, the engine gathers context from parent scenes, global story variables, user data, etc. This scoping ensures **local variables** inherit from broader contexts while still enabling overrides or expansions in deeper blocks.



Managing the ASG
----------------

### Core Narrative Management

When the user (or an AI “navigator”) moves the “cursor” to a scene node:

1. **Check Redirects** – The node might auto-forward to another node.  
2. **Gather Context** – Collect parent scopes, global story state, user data.  
3. **Check Conditions** – Evaluate whether the node is available. If not, the story might branch or block the traversal.  
4. **Apply Effects** – Update stats, inventory, or relationships if the node is successfully entered.  
5. **Render Content** – Generate text and media fragments to append to the “journal.”  
6. **Check Continuations** – If the node offers choices or auto-transitions, guide the user or system to the next node.

The **journal** is the linear record of everything that’s “collapsed” from the possible story graph. Each new node entry appends fragments (text, images, etc.) to the journal. The data layer persists this so it can be undone, redone, or branched.

### Data and Serialization

Because stories can be large, **dynamic**, and multi-user:

- **Everything is stored as graph nodes** referencing one another by ID (including the user object, story history, journal entries).  
- **Undo/Redo** can be handled via snapshot or diff-based versioning of the node registry.  
- **User Data** (achievements, cross-story progress) can be stored in a global or per-user node, letting multiple stories share references.  
- **Stateless Service** approach means you load the relevant story graph from the data layer on each request, update it, and serialize changes back.

### Hooks and Plugins

A **critical** aspect of **tANGL** is allowing authors (or advanced designers) to inject **custom logic** at many points:

- **Compile/Load Hooks** – Before or after the DSL is parsed and turned into an ASG template.  
- **Graph Creation** – On new story instance or node creation, possibly randomizing stats or pulling from external data.  
- **Traversal Hooks** – On node entry, effect evaluation, condition checks, or final rendering steps.  
- **Serialization Hooks** – On save/load for custom fields or data transformations.

These **hooks** support new node types, advanced validations, AI-based generation, or specialized behaviors (like skill checks or day/night cycles). The **Python reference** implementation might allow decorators to register these hook functions, specifying priorities and how they override or augment normal pipeline steps.

### Service Interaction

Clients (CLI, web, or others) typically:

1. **Read** the current story journal to see what has happened so far.  
2. **Submit a choice or action**, which triggers the business layer to move the narrative cursor, apply logic, and generate new fragments.  
3. **Request** metadata (map of the world, summary of open quests) or updates (like available new arcs).  
4. **Manage** accounts and user sessions (start a new story, load an old one, handle cross-story achievements).

The service layer may also **federate** tasks to external microservices (like a generative AI service that creates images or extra text snippets on demand).

### Putting It All Together

1. **Author** defines a world via YAML/DSL plus Python (or other language) hooks.  
2. **Engine** compiles this into a robust **Abstract Story Graph** template.  
3. **When a user starts** the story, the engine clones/instantiates the graph (optionally spawning more dynamic nodes).  
4. **As the user navigates**:
   - Conditions are checked, effects applied, and text/media appended to the “journal.”  
   - The data layer logs each version for undo/redo or alternate branching.  
5. **Presentation** (CLI, web, etc.) fetches the updated journal and user progress, displaying it with appropriate style or media.  
6. **Hooks** can intercept or enhance each step—like injecting new subquests, performing custom validations, or calling AI generation.

Conclusion
----------

**tANGL** thus provides a **unifying framework** for complex interactive narratives, supporting everything from short linear tales to large sandbox RPGs with concurrency, **modular expansions**, dynamic node creation, advanced branching, multi-user collaboration, or AI-driven plot expansions. By **cleanly separating** the data (storage), business (logic), and presentation (front-end) concerns, **tANGL** remains **highly extensible** and capable of evolving with new technologies and authoring paradigms.
