from pathlib import Path
import copy
import logging
from typing import Callable, Literal
import importlib
import io
import re

# from bson.binary import VECTOR_SUBTYPE
from pydantic import field_validator, ValidationInfo, Field
from lxml import etree
from lxml.etree import Element
import PIL.Image
from PIL.Image import Image

from tangl.config import settings
from tangl.core.entity import Singleton
from . import __title__, __version__
from .svg_source_manager import SvgSourceManager
from .svg_group import SvgGroup
# from .svg_spec import SvgSpec

Svg = str  # xml format string
SvgSpec = object
SVG_RENDERER = Literal["cairosvg", "playwright"]

DEFAULT_SVG_RENDERER = settings.content.svg.renderer
logger = logging.getLogger(__name__)

VECTOR_FORGE_INFO = f' Generated by {__title__} ({__version__}) '

class VectorForge:
    """
    Implements MediaForgeP
    """

    # only required to create source manager
    resources: str = None
    source_fp: Path = None
    pre_processor: Callable[[etree.Element], etree.Element] = None

    source_manager: SvgSourceManager = Field(None, validate_default=True)
    post_processor: Callable[[etree.Element], etree.Element] = None

    def get_svg_structure(self):
        # convenience accessor
        return self.source_manager.get_svg_structure()

    def create_media(self, spec: SvgSpec) -> tuple[Svg, SvgSpec]:
        ...

    @field_validator('source_manager', mode="before")
    def _create_source_manager_if_req(cls, value, info: ValidationInfo):
        logger.debug("creating source manager")
        if not value:
            source_fp = info.data['source_fp']
            if r := info.data.get('resources'):
                source_fp = importlib.resources.files(r) / source_fp
            pre_processor = info.data.get('pre_processor')
            value = SvgSourceManager.from_file(source_fp, pre_processor)
        return value

    def group_ids_to_group_root(self, group_ids) -> SvgGroup:
        group_root = SvgGroup()
        for group_id in group_ids:
            if isinstance(group_id, tuple):
                group_id = "/".join(group_id)
            try:
                el = self.source_manager.find(group_id)
                if el is None:
                    raise KeyError
                el = copy.deepcopy( el )
                group_root.add( el )
            except KeyError:
                logger.warning(f"couldn't find group_id {group_id}")
                continue
        return group_root

    def group_ids_to_svg(self,
                         group_ids,
                         bgcolor = None) -> Element:
        # Create a new SVG root element
        svg_root = etree.Element('svg',
                                 nsmap=self.source_manager.nsmap,
                                 attrib=self.source_manager.attrib)

        # Generate the group root from the group IDs
        group_root = self.group_ids_to_group_root(group_ids)
        # Convert the group root to an lxml element
        group_root_el = group_root.to_el()
        # Append the group root element to the SVG root element
        svg_root.append(group_root_el)

        # Add bgcolor
        if bgcolor:
            # stroke:white can be helpful for debugging on dark bgs
            svg_root.attrib["style"] = f"background-color:{bgcolor};"

        if self.post_processor:
            svg_root = self.post_processor(svg_root)

        # Add generator comment
        comment = etree.Comment(VECTOR_FORGE_INFO)
        svg_root.insert(0, comment)

        # Return the SVG root element
        return svg_root

    @classmethod
    def to_string(cls, svg_root: etree._Element, pretty_print=False, encoding="unicode"):
        return etree.tostring(svg_root,
                              xml_declaration=False,
                              pretty_print=pretty_print,
                              encoding=encoding)

    @classmethod
    def to_file(cls, svg_root: etree._Element, output_fp):
        s = cls.to_string( svg_root, encoding='utf8' )
        with open(output_fp, 'wb') as f:
            f.write(s)

    @classmethod
    def to_png(cls,
               svg_root: etree._Element = None,
               svg_fp: Path | str = None,
               output_fp: Path | str = None,
               dims = None,
               force_aspect = None,
               as_bytes = False,
               renderer: SVG_RENDERER = DEFAULT_SVG_RENDERER) -> bytes | Image:

        if svg_fp:
            with open(svg_fp, 'r') as f:
                svg = f.read()
        elif svg_root:
            svg = cls.to_string(svg_root, encoding="unicode")
        else:
            raise ValueError("Requires `svg_root` or `svg_file` path")

        match force_aspect:
            case "sdxl_portrait":
               dims = [832, 1216]
            case _:
                pass

        match renderer:
            case "cairosvg":
                from .cairosvg_render import render_svg
                png_bytes = render_svg(svg, dims=dims)
            case "playwright":
                from .playwright_render import render_svg
                import asyncio
                png_bytes = asyncio.run(render_svg(svg, dims))
            case _:
                raise TypeError(f"No svg renderer for {renderer}")

        if as_bytes:
            return png_bytes

        im = PIL.Image.open(io.BytesIO(png_bytes))
        if output_fp:
            im.save(output_fp)

        return im
