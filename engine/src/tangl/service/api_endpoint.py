from __future__ import annotations
from dataclasses import dataclass
from enum import Enum, IntEnum
from typing import Callable, Any, Type, get_type_hints, Mapping
import functools
import inspect

from pydantic import BaseModel, model_validator, Field

import logging

logger = logging.getLogger(__name__)

class AccessLevel(IntEnum):
    """
    Defines the access level for an API endpoint or user.

    :cvar PUBLIC: Minimal access required, does not need user credentials.
    :cvar USER: Standard user access. Requires valid user.
    :cvar RESTRICTED: Elevated or admin-like access level.
    """
    PUBLIC     = 10
    USER       = 50
    RESTRICTED = 100

class MethodType(Enum):
    """
    Represents the primary HTTP-like verb or action for the endpoint.

    :cvar CREATE: Create or insert operation, typically read/write, returns the created object to insert into context
    :cvar READ: Read or retrieve operation, typically read-only, returns content fragments, info, or media
    :cvar UPDATE: Modify or update operation, typically read/write, returns runtime info
    :cvar DELETE: Remove or destroy operation, returns a list of object id's to delete from context
    """
    CREATE = "create"            # Read/write, runtime response
    READ   = "read"              # Read only, content, info, or media response
    UPDATE = "update"            # Read/write, runtime response
    DELETE = "delete"            # Rw user/ro story, runtime response

    def http_verb(self) -> str:
        # Figure out HTTP method from method_type
        http_verb_map = {
            self.CREATE: "POST",
            self.READ: "GET",
            self.UPDATE: "POST",
            # Usually PUT or PATCH, but our update is really a "DO_ACTION"
            self.DELETE: "DELETE",
        }
        return http_verb_map[self]

class ResponseType(Enum):
    """
    Classifies the type of response generated by an endpoint.

    :cvar CONTENT: Data is a list of content- or kv-fragments.
    :cvar INFO: Data is an informational model, e.g., metadata, user details.
    :cvar RUNTIME: Acknowledgment or status model, e.g., for create/delete.
    :cvar MEDIA: Binary or MIME-typed data (e.g., images, audio).
    """
    CONTENT = "content"          # List of content fragments
    INFO    = "info"             # User, world-, or sys-info model
    RUNTIME = "runtime"          # Acknowledgement model
    MEDIA   = "media"            # Raw or MIME-typed media data

@dataclass(frozen=True)
class PreprocessResult:
    """Outcome from a preprocessor execution."""

    args: tuple[Any, ...] | None = None
    kwargs: Mapping[str, Any] | None = None
    skip_main: bool = False
    result: Any = None

    @classmethod
    def skip(cls, result: Any = None) -> "PreprocessResult":
        """Return a result without invoking the endpoint body."""

        return cls(args=None, kwargs=None, skip_main=True, result=result)


@dataclass(frozen=True)
class PostprocessResult:
    """Outcome from a postprocessor execution."""

    result: Any
    stop: bool = False

    @classmethod
    def stop_with(cls, result: Any) -> "PostprocessResult":
        """Return ``result`` and skip remaining postprocessors."""

        return cls(result=result, stop=True)


class ApiEndpoint(BaseModel):
    """
    Represents metadata about a single endpoint in an application.

    An ApiEndpoint is built around a target function (the actual
    controller method). This class infers method types and response
    types from naming conventions (``create_``, ``get_``, etc.) or
    from explicitly supplied parameters.

    It also supports **preprocessors** and **postprocessors**—callables that
    run before and after the main function, respectively. This can be
    used for logging, data manipulation, or injecting dependencies.

    :param func: The underlying callable (function or method).
    :param name: The explicit name of this endpoint. If omitted, inferred from ``func.__name__``.
    :param group: Logical grouping or category of this endpoint. Often derived from the class name.
    :param method_type: The method type (CRUD-like), e.g. :attr:`MethodType.CREATE`. Inferred from name if not supplied.
    :param response_type: A classification for the endpoint’s return type, e.g. :attr:`ResponseType.INFO`.
    :param access_level: The required access level to call this endpoint. Defaults to ``RESTRICTED``.
    :param preprocessors: A list of callables run before ``func`` is invoked.
    :param postprocessors: A list of callables that take the result of ``func`` and return a possibly modified result.
    """
    func: Callable
    name: str
    group: str
    method_type: MethodType
    response_type: ResponseType
    access_level: AccessLevel = AccessLevel.RESTRICTED  # default to restricted, require param to make public
    preprocessors: list = Field(default_factory=list)
    postprocessors: list = Field(default_factory=list)

    @model_validator(mode="before")
    @classmethod
    def _infer_metadata_fields(cls, data):
        """
        Infers missing metadata (e.g., method_type or response_type) based on
        naming conventions. Raises ``ValueError`` if the function name does not
        match an expected pattern.

        :param data: A dictionary of fields being validated.
        :return: The updated dictionary with any inferred fields.
        :raises ValueError: If no valid method type can be inferred from the function name.
        """
        # 'data' is a dict of the input values
        func = data.get("func")

        # 1) Infer name from func
        if data.get("name") is None and func is not None:
            data["name"] = func.__name__

        # 2) Infer group from qualname
        if data.get("group") is None and func is not None:
            parts = func.__qualname__.split(".")
            if len(parts) > 1:
                data["group"] = parts[-2].replace("Controller", "").lower()

        # 3) Infer method_type from name
        if data.get("method_type") is None:
            name = data.get("name")
            if name is None:
                raise ValueError("Cannot infer method_type: name is missing.")
            if name.startswith("get_"):
                data["method_type"] = MethodType.READ
            elif name.startswith("create_") or name.startswith("load_"):
                data["method_type"] = MethodType.CREATE
            elif name.startswith("drop_") or name.startswith("unload_"):
                data["method_type"] = MethodType.DELETE
            elif name.startswith("update_") or name.startswith("do_"):
                data["method_type"] = MethodType.UPDATE
            else:
                raise ValueError(f"Unable to infer method type from: {name}")

        # 4) Infer response_type from method_type and name
        if data.get("response_type") is None:
            mtype = data["method_type"]
            name = data["name"]
            if mtype in (MethodType.CREATE, MethodType.DELETE, MethodType.UPDATE):
                data["response_type"] = ResponseType.RUNTIME
            else:
                if "info" in name:  # or return type is "SomethingInfo"
                    data["response_type"] = ResponseType.INFO
                elif "content" in name:
                    data["response_type"] = ResponseType.CONTENT
                elif "media" in name:  # or return type is "MediaDataType"
                    data["response_type"] = ResponseType.MEDIA
                else:
                    # fallback, or raise error
                    raise ValueError(f"Unable to infer response type from: {name}")

        # 5) Discard any None params to force fallback to defaults
        data = { k: v for k, v in data.items() if v is not None }

        return data

    def type_hints(self) -> dict[str: Any]:
        """
        Returns type hints for the underlying function.

        :return: A dictionary mapping parameter names (and "return") to Python types.
        """
        hints = get_type_hints(self.func)
        return hints

    def __call__(self, *args, **kwargs):
        """
        Invokes the target function, running any pre and post processors.

        :param args: Positional arguments for the target function.
        :param kwargs: Keyword arguments for the target function.
        :return: The result of the target function, optionally modified by postprocessors.
        """
        logger.debug(f"calling target function: args={args} kwargs={kwargs}")

        # Optionally run preprocessors:
        for pre in self.preprocessors:
            decision = pre(args, kwargs)

            if isinstance(decision, PreprocessResult):
                if decision.args is not None:
                    args = tuple(decision.args)
                if decision.kwargs is not None:
                    kwargs = dict(decision.kwargs)
                if decision.skip_main:
                    return decision.result
                continue

            if decision is None:
                continue

            try:
                args, kwargs = decision
            except (TypeError, ValueError) as exc:
                raise TypeError(
                    "Preprocessor must return (args, kwargs) or PreprocessResult"
                ) from exc

        result = self.func(*args, **kwargs)

        # Optionally run postprocessors:
        for post in self.postprocessors:
            decision = post(result)

            if isinstance(decision, PostprocessResult):
                result = decision.result
                if decision.stop:
                    return result
                continue

            if decision is None:
                result = None
            else:
                result = decision

        return result

    # Decorator for component API definition
    @classmethod
    def annotate(cls,
                 name: str = None,
                 group: str = None,
                 method_type: MethodType = None,
                 response_type: ResponseType = None,
                 access_level: AccessLevel = None,
                 preprocessors: list = None,
                 postprocessors: list = None):
        """
        Decorator that transforms a function into an :class:`ApiEndpoint` instance.

        Usage example::

            class MyController:
                @ApiEndpoint.annotate()
                def get_something_info(self, item_id: str):
                    return {"id": item_id, "info": "..."}

            # The above automatically sets method_type=READ, response_type=INFO

        :param name: Explicit endpoint name (defaults to function name).
        :param group: Group or category for the endpoint. Inferred from the containing class name if absent.
        :param method_type: CRUD-like method type (READ, CREATE, etc.). If not provided, inferred from the name prefix.
        :param response_type: Classification of the return data (INFO, CONTENT, etc.).
        :param access_level: Required permission level (:class:`AccessLevel`) to call this endpoint.
        :param preprocessors: A list of callables that run before the main function (takes same args).
        :param postprocessors: A list of callables that take the result of the main function and can modify it.
        :return: A decorator that wraps the target function in an :class:`ApiEndpoint`.
        """

        def decorator(func: Callable):
            api_endpoint = ApiEndpoint(
                func=func,
                name=name,
                group=group,
                method_type=method_type,
                response_type=response_type,
                access_level=access_level,
                preprocessors=preprocessors,
                postprocessors=postprocessors
            )

            @functools.wraps(func)
            def wrapped(*args, **kwargs):
                # Delegate the call to the ApiEndpoint instance
                return api_endpoint(*args, **kwargs)

            # So we can discover or retrieve the metadata later:
            wrapped._api_endpoint = api_endpoint
            return wrapped

        return decorator


class HasApiEndpoints:
    """
    Mixin base class that discovers decorated endpoints within a class.

    Any method in a subclass that is decorated with :meth:`ApiEndpoint.annotate`
    will automatically be collected by :meth:`.get_api_endpoints`. This allows
    reflection-based frameworks (like a ServiceManager) to auto-register all
    endpoints in a controller class.

    Usage example::

        class MyController(HasApiEndpoints):
            @ApiEndpoint.annotate()
            def get_data(self):
                return "some data"

        # Reflect all endpoints:
        all_endpoints = MyController.get_api_endpoints()

    """
    @classmethod
    def get_api_endpoints(cls) -> dict[str, ApiEndpoint]:
        """
        Discovers all methods decorated with ``ApiEndpoint.annotate`` in this class.

        :return: A dictionary mapping method names to their :class:`ApiEndpoint` objects.
        """
        endpoints = {}
        for name, method in inspect.getmembers(cls, predicate=callable):
            endpoint_method = getattr(method, "_api_endpoint", None)
            if isinstance(endpoint_method, ApiEndpoint):
                endpoints[name] = endpoint_method
        return endpoints

